// fibonacci(n)
// num -> num
{
    // initial data: [0, 1]
    Numerical Reflection: 0
    Numerical Reflection: 1
    Numerical Reflection: 2
    Flock's Gambit

    // recursive block
    {
        // executed on halt, not during regular execution
        Bookkeeper's Gambit: v

        // main recursive function

        // calculate and append current fibonacci number
        Rotation Gambit II
        Gemini Decomposition
        Retrograde Purification
        
        Numerical Reflection: 0
        Numerical Reflection: 2
        Selection Exaltation
        Flock's Disintegration
        
        Additive Distillation
        Integration Distillation
        
        // continue if n >= len(data), otherwise halt
        // eg. fibonacci(3) is at data[3], so n == 3 < 4 == len(data)
        Dioscuri Gambit
        Abacus Purification
        Maximus Distillation II
        
        Numerical Reflection: 4
        Fisherman's Gambit
        Undertaker's Gambit
        Speaker's Decomposition
        Augur's Exaltation
        Hermes' Gambit
    }
    Numerical Reflection: 0 // filler iota (shorter than removing the bookkeeper here)
    Prospector's Gambit
    Hermes' Gambit

    // get result
    Jester's Gambit
    Selection Distillation
}
